{
  "title": "RiskManagerV2",
  "description": "Test cases for RiskManager contract",
  "stories": [
    {
      "description": "GetBestStrategy should return empty in StrategyProvider if strategy is not qualified, defaultStrategy is not set",
      "setActions": [
        {
          "contract": "strategyProvider",
          "action": "setBestStrategy(uint256,bytes32,(address,address,bool)[])",
          "args": {},
          "expect": "success",
          "message": ""
        }
      ],
      "getActions": [
        {
          "contract": "riskManager",
          "action": "getBestStrategy(uint256,bytes32)",
          "args": {},
          "expectedValue": []
        }
      ],
      "cleanActions": []
    },
    {
      "description": "GetBestStrategy should return the best strategy in StrategyProvider if strategy is qualified",
      "setActions": [
        {
          "contract": "registry",
          "action": "updateRPPoolRatings(uint256,(uint8,uint8))",
          "args": {
            "poolRatingRange": [0, 10]
          },
          "expect": "success",
          "message": ""
        },
        {
          "contract": "registry",
          "action": "approveLiquidityPool(address[])",
          "args": {},
          "expect": "success",
          "message": ""
        },
        {
          "contract": "registry",
          "action": "rateLiquidityPool((address,uint8)[])",
          "args": { "score": [2, 2, 2] },
          "expect": "success",
          "message": ""
        },
        {
          "contract": "strategyProvider",
          "action": "setBestStrategy(uint256,bytes32,(address,address,bool)[])",
          "args": {},
          "expect": "success",
          "message": ""
        }
      ],
      "getActions": [
        {
          "contract": "riskManager",
          "action": "getBestStrategy(uint256,bytes32)",
          "args": {},
          "expectedValue": ""
        }
      ],
      "cleanActions": [
        {
          "contract": "registry",
          "action": "revokeLiquidityPool(address[])"
        }
      ]
    },
    {
      "description": "GetBestStrategy should return the default strategy in StrategyProvider if strategy is not qualified (liquidityPool is not approved)",
      "setActions": [
        {
          "contract": "strategyProvider",
          "action": "setBestStrategy(uint256,bytes32,(address,address,bool)[])",
          "args": {},
          "expect": "success",
          "message": ""
        },
        {
          "contract": "strategyProvider",
          "action": "setBestDefaultStrategy(uint256,bytes32,(address,address,bool)[])",
          "args": { "score": [2, 2, 2] },
          "expect": "success",
          "message": ""
        }
      ],
      "getActions": [
        {
          "contract": "riskManager",
          "action": "getBestStrategy(uint256,bytes32)",
          "args": {},
          "expectedValue": ""
        }
      ],
      "cleanActions": [
        {
          "contract": "registry",
          "action": "revokeLiquidityPool(address[])"
        }
      ]
    },
    {
      "description": "GetBestStrategy should return the default strategy in StrategyProvider if strategy is not qualified (rate is not in expected range)",
      "setActions": [
        {
          "contract": "registry",
          "action": "updateRPPoolRatings(uint256,(uint8,uint8))",
          "args": {
            "poolRatingRange": [3, 10]
          },
          "expect": "success",
          "message": ""
        },
        {
          "contract": "registry",
          "action": "approveLiquidityPool(address[])",
          "args": {},
          "expect": "success",
          "message": ""
        },
        {
          "contract": "registry",
          "action": "rateLiquidityPool((address,uint8)[])",
          "args": { "score": [1, 1, 1] },
          "expect": "success",
          "message": ""
        },
        {
          "contract": "strategyProvider",
          "action": "setBestStrategy(uint256,bytes32,(address,address,bool)[])",
          "args": {},
          "expect": "success",
          "message": ""
        },
        {
          "contract": "strategyProvider",
          "action": "setBestDefaultStrategy(uint256,bytes32,(address,address,bool)[])",
          "args": { "score": [5, 5, 5] },
          "expect": "success",
          "message": ""
        }
      ],
      "getActions": [
        {
          "contract": "riskManager",
          "action": "getBestStrategy(uint256,bytes32)",
          "args": {},
          "expectedValue": ""
        }
      ],
      "cleanActions": [
        {
          "contract": "registry",
          "action": "revokeLiquidityPool(address[])"
        },
        {
          "contract": "strategyProvider",
          "action": "setBestStrategy(uint256,bytes32,(address,address,bool)[])"
        },
        {
          "contract": "strategyProvider",
          "action": "setBestDefaultStrategy(uint256,bytes32,(address,address,bool)[])"
        }
      ]
    }
  ],
  "standaloneStories": [
    {
      "description": "[Upgradability] Should be able to use functions and variables in new contracts and maintains old variable states",
      "setActions": [
        {
          "contract": "riskManager",
          "action": "become(address)",
          "args": {},
          "executor": "owner",
          "expect": "success",
          "message": ""
        }
      ],
      "getActions": [
        {
          "contract": "riskManager",
          "action": "isNewContract()",
          "args": {},
          "expectedValue": true,
          "expectedMultiValues": {}
        }
      ],
      "cleanActions": [
        {
          "contract": "riskManager",
          "action": "deployRiskManager()"
        }
      ]
    },
    {
      "description": "GetBestStrategy should revert with non-exist underlyingTokenHash",
      "setActions": [],
      "getActions": [
        {
          "contract": "riskManager",
          "action": "getBestStrategy(uint256,bytes32)",
          "args": {
            "riskProfileCode": "1"
          },
          "expectedValue": "!TokenHashExists"
        }
      ],
      "cleanActions": []
    },
    {
      "description": "GetBestStrategy should revert with non-exist risk profile code",
      "setActions": [
        {
          "contract": "registry",
          "action": "approveAndMapTokenHashToToken(bytes32,address[])",
          "args": {},
          "expectedValue": ""
        }
      ],
      "getActions": [
        {
          "contract": "riskManager",
          "action": "getBestStrategy(uint256,bytes32)",
          "args": {
            "riskProfileCode": "4"
          },
          "expectedValue": "!Rp_Exists"
        }
      ],
      "cleanActions": []
    }
  ]
}
